# Understanding state

## What is State (4:15)

There are two ways that data gets handle than react, props and state. So far we built our application using functions that taken props and return react elements. But props are read-only or immutable. A component can only read the props given to it, never change them. For any data that's going to change, we have to use state. Let's dig into this concept.

In react, **state is the data you want to track in your app**. State is what allows you to create components that are dynamic and interactive, and it's the only data that changes over time. In react, this data is stored in state.

**State itself is a regular JavaScript object with properties that define the pieces of data that change**. For example, if I look at the final app in React Dev Tools and select the app component, we see this new section in the right panel labeled state, and it contains an array with three objects. If I expand one of the objects we see its properties, id, name, and score. This should look familiar.

Now the biggest difference between the players array, we're currently passing to app via props and this array and state, is that data in state is not read-only. This data can change. For example, if I click to remove a player, notice how the array changes from 3 to 2 objects. This triggers a State change that affects all the components that take in this data. For instance, the total players number changes to 2 and the total points decrease. And if I click to increase one of the player score, we see the score update in state as well. And we know that this state is also being shared with the stats component up top because we see the total points increase and decrease as we update the score.

In fact, I can even update the score here in the state object and watch the value immediately change on screen. I'll do the same with one of the names, and so on. So as you can see, **state is what keeps your UI in sync with your data**. As the data changes, different components of the app will update what they show to the user. And normally, in a regular JavaScript application, the more data you have and the more spread out it is the more complex the application becomes to maintain and debug. So react provides a more convenient way to store and maintain your data with state.

Props still play a major role in your application, data from state is distributed through props. For example, each player component still receives the name, score, and other information you'll learn about later from props. Props are still how you get data into a component. You can learn more about what defines state in the teachers notes. To begin using state, we need to make a few changes in our app. State is only available to components that are class components. So in the next video, 4:10 we´ll begin by converting a function component to a class component.

Resources

- [Adding Local State to a Class – React docs](https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class)
- [Component State – React docs](https://reactjs.org/docs/faq-state.html)
- [props vs state](https://github.com/uberVU/react-guide/blob/master/props-vs-state.md)

## Create a Component as a Class (4:00)

## Create a Stateful Component (4:21)

In this video, we're going to create a stateful component by first defining 0:04 an initial state inside the counter class. 0:07 You'll learn that in React state changes over time, 0:11 usually in response to users action. 0:13 So what part of the counter will change when users interact with it? 0:18 The score will increase or decrease depending on which button they click. 0:22 Score is our state. 0:24 So now let's go into our Counter component and start creating state. 0:28 Since state is an object, you create and 0:31 initialize state within a class inside the constructor method. 0:35 So first, I'll set up a constructor. 0:38 Again, if you're not familiar with classes and constructor methods, be sure to review 0:42 the Tree House videos posted in the teacher's notes with this video. 0:46 Inside the constructor, I'll call super in 0:49 order to call the constructor of the component class that we're extending. 0:55 And this needs to be done before we can use the this keyword 0:58 within the constructor. 1:00 Then to initialize our component state, 1:03 write this.state and set it equal to an object. 1:09 You must name this object state otherwise this will not work. 1:14 Since state is data that changes over time, we first need to set an initial 1:19 state or the state of the component when it first bounce. 1:23 The state in our counter is going to be the score we want to display for 1:28 each player. 1:29 I'll call the state score and set it to 0 by default. 1:33 Now that we've initialized state, over end React dev tools, 1:37 select a counter component inside a player component. 1:41 And you should see a new property called State up here in the right pane. 1:45 We see the course state and it's value is 0. 1:49 Next, let's remove the score prop being passed to 1:54 the counter and player components. 1:58 Because Counter is now maintaining its own score state, 2:01 it doesn't need the score information from its parent player component. 2:06 You access state in a similar way to how you access props. 2:11 In the Counter components render method, 2:14 replace this.props.score with this.state.score. 2:18 You can think of the render method in a class component 2:22 as being a function of not just props, but props and state. 2:26 In other words, if either props or state changes, 2:30 React executes the render method to update what gets displayed to the user. 2:36 Now once we refresh our app, 2:38 we see that all the players scores are set to the initial state of 0. 2:43 We can even change the score state of a counter component 2:48 instance in React Dev Tools and see the score change on the page. 2:53 Great, so you've just built your first stateful react component. 2:57 Before we move on, 2:59 I want to teach you a second way you can initialize state inside a React component. 3:05 A shortcut, 3:06 you'll often see state initialized inside a class constructor like this. 3:11 But you can also initialize state directly inside the class definition, 3:16 using a class property. 3:18 You omit the constructor method and super all together, and 3:22 reference the state property directly. 3:26 You don't need to write it as this.state, just state, and 3:30 set it equal to the object. 3:35 This class properties syntax is a feature of JavaScript that's currently not 3:39 supported in all browsers. 3:40 Since we're using the Babel transpiler in our app, 3:44 we don't have to worry about browser's support. 3:47 Babel will transpile our code and add a constructor for us behind the scenes. 3:53 The way you initialize state is up to you. 3:55 I prefer the class property syntax because it allows for a cleaner class component 4:00 and I don't have to remember to setup a constructor and call super. 4:03 So that's what I'm gonna be using moving forward. 4:06 All right, we've moved our score into a state object 4:10 instead of getting the score from props. 4:12 But so far, it doesn't seem to have a benefit. 4:15 Up next, you'll learn how to modify state from inside a component, 4:18 something you're not able to do with props.

## Handling Events (2:56)

## Updating State (2:14)

## Bind Event Handlers to Components (2:14)

When we click the plus button to increment a player's score, we get an error in the console that reads, 0:05 Uncaught TypeError: Cannot read property 'setState' of undefined. 0:09 The issue here is that we are referencing this.setState inside the increment 0:14 score method but this is actually undefined inside the method. 0:19 For example, I'll comment out the setState method and log this to the console. 0:26 When I click a plus button, notice how this returns undefined. 0:32 In objects or classes, this usually refers to the parent that owns the method. This should be the counter class. 0:40 Since this is undefined, our method cannot access this.setState or 0:44 this.state when the onClick event is triggered. 0:47 So why is it undefined? 0:49 You see, when you create a class component that extends from React.Component, 0:54 any custom methods you create are not bound to the component by default. 0:58 So we've lost our binding to the component, 1:01 therefore we're not able to reference it from within our method. 1:04 So it's important to remember that you need to bind your custom methods, 1:09 so that this refers to the component. 1:11 And there are several ways to bind the thisContext in React. 1:15 A common way is to call bind in the render method. 1:18 Each counter component that gets mounted into the dom is an instance 1:23 of the counter class. 1:25 So inside the render method, this refers to the counter component instance, 1:30 as you can see here in the console. 1:36 In the button's onClick event, I'll call the JavaScript 1:41 bind method on this.incrementScore, and pass it the desired context via this. 1:49 Now let's run our code, click the plus button and great, 1:54 we see that the console logged to this now returns the counter. 1:59 So now I'll uncomment this.setState, and 2:02 remove the console log inside the increment score method. 2:11 And we can see that our counter now works. 2:16 The other common way to bind event handlers is with an arrow function. 2:20 So in my button, 2:22 I'll pass an arrow function to the onClick event that calls this.incrementScore 2:31 Over in the browser, our counter works the same way. 2:35 And we don't even need to bind this, 2:38 that's because arrow functions use what's called a lexical this binding which 2:43 means that it automatically bind them to the scope in which they are defined. 2:47 We know that inside the render method, 2:50 this refers to the counter component instance. 2:52 The arrow function is enclosed inside the render method, 2:56 so it takes on that same context. 2:58 And the this value inside it will properly point to the counter component instance. 3:03 There are even more ways to bind event handlers, for example, the most 3:08 common way to define an event handler in React is with an arrow function. 3:13 We learned that arrow functions are automatically bound to the scope in which 3:17 they are defined. 3:18 So if we rewrite the increment score method as an arrow function, 3:23 the function gets bound to the component instance. 3:27 The arrow function is enclosed inside the counter class, so 3:31 the context is the component instance. 3:34 Now we don't need to worry about binding it in the on-click event or 3:37 in the constructor which is yet another way to bind custom methods. 3:41 We can simply reference and call the function in the onClick event with 3:45 this.incrementScore, make sure there are no parentheses at the end. 3:55 Good, all right, now that you´ve learned how to create event handlers, 4:00 use React events and update state, why don´t you 4:03 write a function called decrement score that increases the score by one? 4:08 Go ahead and pause the video and give it a try. 4:12 So decrement score should work just like increment score, but 4:17 subtracting one instead of adding one. 4:19 So I'm going to write the event handler as an arrow function by simply 4:25 copying the increment score function and changing it to decrement score and 4:31 I'll subtract one from the score by changing the plus operator a minus. 4:37 Next, I'll add React's onClick event to the minus button, 4:43 and pass it, this.decrementScore. 4:48 Let's save our code and test that in the browser 5:01 All right, our counter feature now works.

## Update State Based on Previous State

Our counter score is updating correctly. 0:03 However, we're still mutating or altering state directly. 0:07 Notice how we're updating the component score state by directly accessing 0:11 this.state.score. 0:13 The way setState works is it takes the object past to it with the updated 0:18 state and eventually merges it into the component's current state. 0:23 According to the React docs, a state update may be asynchronous. 0:26 In other words, 0:27 sometimes updates to the DOM don't happen immediately when you call this.setState. 0:33 If you have multiple setState calls inside of an event handler, 0:36 React will often batch, or bundle the updates together into a single update. 0:40 This is done for 0:41 performance reasons, so that your UI is rerendered more efficiently. 0:45 So because state maybe updated asynchronously, whenever you need to 0:50 update state based on previous state, like update a score based on the previous 0:55 score, you shouldn't rely on this .state to calculate the next state. 1:00 While it's technically possible to change state this way, 1:04 as you can see our counter is working just fine. 1:07 It may not always lead to the component rerendering with the new data and 1:11 could cause state inconsistency. 1:13 So instead of an object, setState also accepts a call back function 1:18 that produces state based on the previous state in a more reliable way. 1:22 So let's first modify the setState method in increment score 1:26 to take a call back function. 1:27 The call back function receives the previous state as its first argument and 1:32 the props at the time the update is applied as an optional second argument. 1:36 We are only going to check the previous value of state before setting a new value, 1:41 so let's pass the call back or 1:43 reference to the previous state with the parameter prevState. 1:48 We will add the arrow then wrap the score property in a return 1:52 statement with curly braces. 2:01 Now we'll replace this.state.score with prevState.score. 2:10 And we'll do the same with the decrement function. 2:33 Our counter still functions the same way, but 2:36 now we have a more reliable way to set state based on previous state. 2:40 Because the callback function is guaranteed to fire after the update is 2:45 applied and rendered out to the DOM. 2:49 And to make the callback more concise, you could omit the return keyword and 2:53 curly braces, by wrapping the body of the function in parentheses. 3:15 So whenever you're updating to a new state based on a previous state, 3:20 it's actively recommended that you use this approach. 3:24 That way, you can be sure that state did indeed update correctly

## Creating the Application State

In these final videos, you'll bring together a lot of what you've learned 0:04 to create a feature that removes players from the app. 0:07 When a user clicks the close icon next to a name, 0:10 that player gets deleted from the scoreboard. 0:13 You learned that the only thing that can change over time and react is state. 0:16 A change in state like increasing the score state by 1, 0:20 results in changes to the UI. 0:22 And when changes are made to the UI like removing a player from the scoreboard, 0:26 your data also changes in response. 0:29 So now you're going to learn how to remove items from state. 0:33 We'll initialize a player state in the app component, then create and 0:37 wire up an event handler that removes a player on click. 0:41 Since the app component is responsible for rendering the player component, 0:46 It's going to own and maintain the player state. 0:49 That state will then be passed down and 0:52 available to the player component as well as all children of App via props. 0:58 First we'll make App a stateful component, 1:02 by converting it from a function to a class, 1:07 with class App extends React.Component. 1:11 Inside the class, Let's add a render method, 1:16 then place the return statement inside the render method. 1:25 Remember state is an object that stores all the data that the component itself 1:30 needs and data that might get passed down to its children. 1:34 So in the App component, let's initialize a player state using a class property.

1:40 First, set state equal to an object. 1:45 Inside the object, add a property named players and set it to an array. 1:53 Next, I'll cut all the objects out of the original 1:57 players array at the top of the file. 2:00 And paste them inside our new players array and state. 2:07 This data is going to be our initial state. 2:10 Now, we just need the name and ID properties right now 2:14 since the score state is being set and updated in the counter component. 2:19 So, I'll go ahead and remove the score property from each object 2:28 And, now we can go up and delete the original players array. 2:33 And we no longer need to pass the player data to 2:36 the App component as props because the data is now in state. 2:40 So let's also delete the initial players prop given to the App component in 2:44 ReactDOM.render. 2:47 Next in the App components render method, 2:51 we need to change our map function to iterate through the players array and 2:56 state, which we can access with this.state. 3:00 So let's replace props.initialPlayers 3:06 with this.state.players. 3:10 And we'll also need to change the total players prop in 3:15 the header to this.state.players.length. 3:24 Over in React Dev Tools, 3:26 you can see that the App component now has a state of players and it's an array. 3:32 And you should see the app display the initial player state, 3:35 much like it always has. 3:41 One important concept to understand is the different types of state. 3:45 There are two main types of state I consider when designing a React tab, 3:49 application state and component state. 3:52 Application state is the main state we typically think about. 3:56 It's usually the data that's available to the entire app. 4:00 In our scoreboard app, application state lives in the app component, and 4:05 all of its child components have access to it. 4:08 The counter however has state that's not shared or 4:12 visible outside of the component. 4:15 It's state required just for 4:16 that component to do it's job like increasing and decreasing the score. 4:21 This type of state is refered to as local component state. 4:26 All right, now that you know more about application and 4:29 component state, in the next video I'll teach you how to remove items from state.
